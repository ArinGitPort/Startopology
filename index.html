<!DOCTYPE html>
<html>
  <head>
    <title>Star Topology Simulator</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
      /* Packet animation styles */
      .packet {
        position: absolute;
        width: 16px;
        height: 16px;
        background-color: #FFEB3B;
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(255, 235, 59, 0.8);
        z-index: 1000;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .packet-trail {
        position: absolute;
        width: 8px;
        height: 8px;
        background-color: rgba(255, 235, 59, 0.5);
        border-radius: 50%;
        z-index: 999;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .pulse-effect {
        animation: pulse 0.5s ease-out;
      }
      @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        100% { transform: scale(2); opacity: 0; }
      }

      /* Dracula Theme Variables */
      :root {
        --bg-light: #f7f9fc;
        --text-light: #2c3e50;
        --primary-light: #3498db;
        --secondary-light: #2980b9;
        --danger-light: #e74c3c;
        --success-light: #27ae60;
        --card-light: #ffffff;
        --border-light: #e0e6ed;

        --bg-dark: #282a36;
        --text-dark: #f8f8f2;
        --primary-dark: #bd93f9;
        --secondary-dark: #6272a4;
        --danger-dark: #ff5555;
        --success-dark: #50fa7b;
        --card-dark: #44475a;
        --border-dark: #6272a4;
      }

      body.light-theme {
        --bg: var(--bg-light);
        --text: var(--text-light);
        --primary: var(--primary-light);
        --secondary: var(--secondary-light);
        --danger: var(--danger-light);
        --success: var(--success-light);
        --card: var(--card-light);
        --border: var(--border-light);
      }

      body.dark-theme {
        --bg: var(--bg-dark);
        --text: var(--text-dark);
        --primary: var(--primary-dark);
        --secondary: var(--secondary-dark);
        --danger: var(--danger-dark);
        --success: var(--success-dark);
        --card: var(--card-dark);
        --border: var(--border-dark);
      }

      /* Theme Toggle Button */
      #themeToggle {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 8px 14px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 2px solid var(--border);
        font-size: 15px;
        font-weight: 500;
      }

      body.light-theme #themeToggle {
        background: #282a36;
        color: #f8f8f2;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      }

      body.dark-theme #themeToggle {
        background: #f8f8f2;
        color: #282a36;
        box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      }

      /* Layout styles */
      .main-layout {
        display: flex;
        min-height: 100vh;
      }

      .sidebar {
        width: 300px;
        flex-shrink: 0;
        padding: 20px;
        overflow-y: auto;
        height: 100vh;
        position: fixed;
        right: 0;
        top: 0;
        z-index: 10;
      }

      .main-content {
        flex-grow: 1;
        margin-right: 300px;
      }

      /* Packet Log */
      .packet-log {
        margin-top: 30px;
      }

      .packet-log h2 {
        font-size: 18px;
        margin-bottom: 15px;
        color: var(--primary);
      }

      .log-entry {
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        font-size: 14px;
        background: rgba(255,255,255,0.1);
      }

      .log-entry.source {
        border-left: 3px solid var(--primary);
      }

      .log-entry.target {
        border-left: 3px solid var(--success);
      }

      .log-entry.error {
        border-left: 3px solid var(--danger);
      }

      .log-container {
        max-height: 300px;
        overflow-y: auto;
        border-radius: 4px;
      }

      .log-time {
        color: var(--secondary);
        font-size: 12px;
        margin-bottom: 5px;
      }

      /* New UI element styles */
      .packet-mode {
        display: flex;
        gap: 20px;
        margin: 10px 0;
      }

      .packet-mode label {
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
      }

      .network-controls {
        display: flex;
        gap: 10px;
        margin: 15px 0;
      }

      /* Traffic visualization */
      .traffic-low {
        color: var(--success);
      }
      
      .traffic-medium {
        color: #FFA500; /* Orange */
      }
      
      .traffic-high {
        color: var(--danger);
      }
    </style>
  </head>
  <body class="light-theme">
    <button id="themeToggle">🌙 Dracula Theme</button>
    
    <!-- User Guide Section -->
    <div id="userGuide" class="user-guide">
      <h2>Star Topology Simulator - User Guide</h2>
      <button id="closeGuide" class="close-guide">×</button>
      <div class="guide-content">
        <h3>Overview</h3>
        <p>This simulator demonstrates a star network topology where all nodes connect to a central hub. Data transmission between nodes must pass through the hub.</p>
        
        <h3>Main Features</h3>
        <ul>
          <li><strong>Node Management:</strong> Add/remove nodes or toggle their active state by clicking on them</li>
          <li><strong>Hub Control:</strong> Toggle the hub state to simulate central point failure</li>
          <li><strong>Packet Transmission:</strong> Send unicast (node to node) or broadcast (node to all) packets</li>
          <li><strong>Network Configuration:</strong> Adjust latency, packet size, and enable/disable collision detection</li>
          <li><strong>Load Testing:</strong> Test network performance under different loads</li>
        </ul>
        
        <h3>Quick Start</h3>
        <ol>
          <li>Select a source node from the dropdown</li>
          <li>Select a target node or choose broadcast mode</li>
          <li>Click "Send Packet" to transmit data</li>
          <li>View detailed packet logging in the right sidebar</li>
        </ol>
        
        <button id="startDemo" class="demo-button">Run Demo Sequence</button>
      </div>
    </div>
    <button id="showGuide" class="show-guide">Show User Guide</button>
    
    <div class="main-layout">
      <div class="main-content">
        <h1>Star Topology Simulator</h1>
        
        <div class="legend">
          <div class="legend-item">
            <span class="legend-color" style="background: #1565c0"></span>Hub
          </div>
          <div class="legend-item">
            <span class="legend-color" style="background: #4caf50"></span>Active Node
          </div>
          <div class="legend-item">
            <span class="legend-color" style="background: #e53935"></span>Inactive Node
          </div>
          <div class="legend-item">
            <span class="legend-color" style="background: #ffeb3b"></span>Data Packet
          </div>
        </div>
        
        <div id="network"></div>
      </div>
      
      <div class="sidebar">
        <h2>Controls</h2>
        
        <!-- Packet Log moved to top for better visibility -->
        <div class="packet-log">
          <h2>Packet Log</h2>
          <div class="log-container" id="packetLog"></div>
        </div>
        
        <div class="status" id="status">
          All connections <span class="active-connection">ACTIVE</span>
        </div>
        
        <div class="status" id="packetStatus"></div>
        
        <!-- Essential Controls Section -->
        <div class="collapsible-section">
          <div class="section-header expanded">
            <h3>Essential Controls</h3>
            <span class="toggle-icon">▼</span>
          </div>
          <div class="section-content">
            <div class="controls">
              <button id="toggleHub">Toggle Hub (ON)</button>
              <button id="resetAll">Reset All</button>
            </div>
            
            <div class="packet-controls">
              <select id="sourceNode">
                <option value="">Select Source Node</option>
                <option value="node1">PC 1</option>
                <option value="node2">PC 2</option>
                <option value="node3">PC 3</option>
                <option value="node4">PC 4</option>
                <option value="node5">PC 5</option>
                <option value="node6">PC 6</option>
              </select>
              <select id="targetNode">
                <option value="">Select Target Node</option>
                <option value="node1">PC 1</option>
                <option value="node2">PC 2</option>
                <option value="node3">PC 3</option>
                <option value="node4">PC 4</option>
                <option value="node5">PC 5</option>
                <option value="node6">PC 6</option>
              </select>
              <div class="packet-mode">
                <label><input type="radio" name="packetMode" value="unicast" checked> Unicast</label>
                <label><input type="radio" name="packetMode" value="broadcast"> Broadcast</label>
              </div>
              <button id="sendPacket">Send Packet</button>
            </div>
          </div>
        </div>
        
        <!-- Advanced Controls Section (Collapsed by default) -->
        <div class="collapsible-section">
          <div class="section-header">
            <h3>Advanced Controls</h3>
            <span class="toggle-icon">▶</span>
          </div>
          <div class="section-content" style="display: none;">
            <button id="autoSimulate">Auto Simulate</button>
            
            <div class="network-controls">
              <button id="addNode">Add Node</button>
              <button id="removeNode">Remove Node</button>
            </div>
            
            <!-- Network Configuration -->
            <div class="config-panel">
              <h3>Network Configuration</h3>
              
              <!-- Latency Simulation -->
              <div class="config-item">
                <label for="latencySlider">Latency (ms): <span id="latencyValue">0</span></label>
                <input type="range" id="latencySlider" min="0" max="1000" step="50" value="0">
              </div>
              
              <!-- Packet Size -->
              <div class="config-item">
                <label for="packetSizeSlider">Packet Size (bytes): <span id="packetSizeValue">64</span></label>
                <input type="range" id="packetSizeSlider" min="32" max="1500" step="32" value="64">
              </div>
              
              <!-- Load Testing -->
              <div class="config-item">
                <label for="loadTestPackets">Test Packets: <span id="loadTestPacketsValue">10</span></label>
                <input type="range" id="loadTestPackets" min="5" max="50" step="5" value="10">
                <button id="runLoadTest">Run Load Test</button>
              </div>
              
              <!-- Collision Detection Toggle -->
              <div class="config-item">
                <label><input type="checkbox" id="enableCollisions" checked> Enable Collision Detection</label>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Load Test Results Section -->
        <div id="loadTestResults" class="load-test-results" style="display: none;">
          <h4>Load Test Results</h4>
          <div class="metric">
            <span>Packets Sent:</span>
            <span id="metricSent" class="metric-value">0</span>
          </div>
          <div class="metric">
            <span>Packets Delivered:</span>
            <span id="metricDelivered" class="metric-value">0</span>
          </div>
          <div class="metric">
            <span>Collisions:</span>
            <span id="metricCollisions" class="metric-value">0</span>
          </div>
          <div class="metric">
            <span>Avg. Delivery Time:</span>
            <span id="metricTime" class="metric-value">0 ms</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      const ipConfigurations = {
        hub: "192.168.1.1",
        node1: "192.168.1.2",
        node2: "192.168.1.3",
        node3: "192.168.1.4",
        node4: "192.168.1.5",
        node5: "192.168.1.6",
        node6: "192.168.1.7",
      };

      const HUB_ACTIVE = "#1565C0";
      const HUB_INACTIVE = "#E53935";
      const NODE_ACTIVE = "#4CAF50";
      const NODE_INACTIVE = "#E53935";
      const PACKET_COLOR = "#FFEB3B";
      const PACKET_SPEED = 750;

      let data, network;
      let hubActive = true;
      let nodeStatus = {};
      let blinkInterval;
      let isAnimatingPacket = false;
      let autoSimulateInterval = null;
      let packetElements = [];
      let packetLogEntries = [];
      let nodeCount = 6; // Track the current number of nodes
      let trafficData = {}; // Track traffic on each connection
      let lastBroadcastTime = 0; // Prevent broadcast spam
      
      // New variables for advanced features
      let packetQueue = []; // For packet queue visualization
      let currentLatency = 0; // Latency in ms
      let currentPacketSize = 64; // Packet size in bytes
      let enableCollisions = true; // Collision detection toggle
      let activePackets = []; // Track packets currently in transit
      let collisionCount = 0; // Track collisions for metrics
      
      // Load test metrics
      let loadTestMetrics = {
        packetsSent: 0,
        packetsDelivered: 0,
        collisions: 0,
        deliveryTimes: []
      };

      // Initialize theme based on user preference
      document.addEventListener('DOMContentLoaded', function() {
        // Check for saved theme preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
          document.body.className = savedTheme;
          updateThemeToggleText();
        }
        
        // Initialize configuration sliders
        initConfigControls();
        
        createNetwork();
        updateVisuals();
        blinkInactiveEdges();
        addLogEntry("Star Topology Simulator initialized", "info");
        
        // User guide controls
        document.getElementById("showGuide").addEventListener("click", function() {
          document.getElementById("userGuide").style.display = "block";
        });
        
        document.getElementById("closeGuide").addEventListener("click", function() {
          document.getElementById("userGuide").style.display = "none";
        });
        
        document.getElementById("startDemo").addEventListener("click", runDemoSequence);
        
        // Initialize collapsible sections
        initCollapsibleSections();
      });
      
      // Function to initialize collapsible sections
      function initCollapsibleSections() {
        const sectionHeaders = document.querySelectorAll('.section-header');
        
        sectionHeaders.forEach(header => {
          header.addEventListener('click', function() {
            // Toggle expanded class
            this.classList.toggle('expanded');
            
            // Update the toggle icon
            const icon = this.querySelector('.toggle-icon');
            if (this.classList.contains('expanded')) {
              icon.textContent = '▼';
            } else {
              icon.textContent = '▶';
            }
            
            // Toggle visibility of content section
            const content = this.nextElementSibling;
            if (content.style.display === 'none' || !content.style.display) {
              content.style.display = 'block';
            } else {
              content.style.display = 'none';
            }
          });
        });
      }
      
      // Theme toggle
      document.getElementById("themeToggle").addEventListener("click", function() {
        const body = document.body;
        if (body.classList.contains("light-theme")) {
          body.classList.remove("light-theme");
          body.classList.add("dark-theme");
          localStorage.setItem('theme', 'dark-theme');
        } else {
          body.classList.remove("dark-theme");
          body.classList.add("light-theme");
          localStorage.setItem('theme', 'light-theme');
        }
        updateThemeToggleText();
      });
      
      // Update theme toggle button text
      function updateThemeToggleText() {
        const button = document.getElementById("themeToggle");
        if (document.body.classList.contains("dark-theme")) {
          button.textContent = "☀️ Light Theme";
        } else {
          button.textContent = "🌙 Dracula Theme";
        }
      }

      /**
       * Creates the star network topology with a central hub and peripheral nodes
       * The hub is placed at the center, with nodes distributed evenly in a circle around it
       */
      function createNetwork() {
        const nodes = [
          {
            id: "hub",
            label: "Hub",
            shape: "image",
            image: "switch-hub.png",
            size: 50,
            font: { size: 16 },
            fixed: true,
            x: 0,
            y: 0,
            borderWidth: 6,
            borderWidthSelected: 6,
            color: { border: HUB_ACTIVE, background: "rgba(255,255,255,0.9)" },
            shadow: true,
            shadowColor: "#1565C0", // blue for hub
            shadowSize: 28,
            shadowX: 0,
            shadowY: 0,
          },
        ];

        const edges = [];
        const radius = 300;

        for (let i = 1; i <= nodeCount; i++) {
          const angle = (i - 1) * ((2 * Math.PI) / nodeCount);
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          const nodeId = `node${i}`;
          
          // Initialize traffic data for this connection if it doesn't exist
          if (!trafficData[nodeId]) {
            trafficData[nodeId] = {
              packetsSent: 0,
              packetsReceived: 0,
              lastUpdate: Date.now()
            };
          }
          
          // Initialize node status if it doesn't exist
          if (nodeStatus[nodeId] === undefined) {
            nodeStatus[nodeId] = true;
          }
          
          // Get the IP (use existing or generate new)
          const nodeIP = ipConfigurations[nodeId] || generateIP(i);
          
          // Make sure IP is in configurations
          if (!ipConfigurations[nodeId]) {
            ipConfigurations[nodeId] = nodeIP;
          }
          
          nodes.push({
            id: nodeId,
            label: `PC ${i}`,
            title: `IP: ${nodeIP}`,
            shape: "image",
            image: "desktop.png",
            size: 40,
            font: { size: 14 },
            fixed: true,
            x,
            y,
            borderWidth: 4,
            borderWidthSelected: 4,
            color: { 
              border: nodeStatus[nodeId] ? NODE_ACTIVE : NODE_INACTIVE, 
              background: "rgba(255,255,255,0.7)" 
            },
            shadow: true,
            shadowColor: nodeStatus[nodeId] ? "#4CAF50" : "#E53935", // green if active, red if inactive
            shadowSize: 20,
            shadowX: 0,
            shadowY: 0,
          });
          edges.push({
            id: `edge${i}`,
            from: "hub",
            to: nodeId,
            color: { color: "#000000" },
            width: 2,
          });
        }

        // If network already exists, destroy it first
        if (network) {
          network.destroy();
          // Clean up any packet elements
          cleanupPacketElements();
        }

        data = {
          nodes: new vis.DataSet(nodes),
          edges: new vis.DataSet(edges),
        };

        network = new vis.Network(document.getElementById("network"), data, {
          physics: false,
          interaction: {
            dragNodes: false,
            dragView: false,
            zoomView: false,
          },
          autoResize: false, // Prevent auto-resizing
          height: "800px",
          width: "800px",
        });

        network.on("click", (params) => {
          if (params.nodes.length && params.nodes[0] !== "hub") {
            toggleNode(params.nodes[0]);
          }
        });
        
        // Update node selectors in UI
        updateNodeSelectors();
      }

      // Generate IP for newly added nodes
      function generateIP(nodeIndex) {
        return `192.168.1.${nodeIndex + 1}`;
      }
      
      // Update node selectors in UI
      function updateNodeSelectors() {
        const sourceSelect = document.getElementById("sourceNode");
        const targetSelect = document.getElementById("targetNode");
        
        // Save current selections
        const sourceVal = sourceSelect.value;
        const targetVal = targetSelect.value;
        
        // Clear options
        sourceSelect.innerHTML = '<option value="">Select Source Node</option>';
        targetSelect.innerHTML = '<option value="">Select Target Node</option>';
        
        // Add options for all current nodes
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          
          // Add to source selector
          const sourceOpt = document.createElement('option');
          sourceOpt.value = nodeId;
          sourceOpt.textContent = `PC ${i}`;
          sourceSelect.appendChild(sourceOpt);
          
          // Add to target selector
          const targetOpt = document.createElement('option');
          targetOpt.value = nodeId;
          targetOpt.textContent = `PC ${i}`;
          targetSelect.appendChild(targetOpt);
        }
        
        // Restore previous selections if they still exist
        if (sourceVal && parseInt(sourceVal.replace('node', '')) <= nodeCount) {
          sourceSelect.value = sourceVal;
        }
        if (targetVal && parseInt(targetVal.replace('node', '')) <= nodeCount) {
          targetSelect.value = targetVal;
        }
      }

      // Log packet activity
      function addLogEntry(message, type = "info") {
        const logContainer = document.getElementById("packetLog");
        const time = new Date().toLocaleTimeString();
        
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        
        const timeSpan = document.createElement("div");
        timeSpan.className = "log-time";
        timeSpan.textContent = time;
        
        const messageDiv = document.createElement("div");
        messageDiv.innerHTML = message;
        
        entry.appendChild(timeSpan);
        entry.appendChild(messageDiv);
        
        // Keep only the latest 50 entries
        packetLogEntries.push(entry);
        if (packetLogEntries.length > 50) {
          packetLogEntries.shift();
        }
        
        // Clear and repopulate the log
        logContainer.innerHTML = "";
        packetLogEntries.forEach(item => {
          logContainer.appendChild(item);
        });
        
        // Scroll to bottom
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      function toggleNode(nodeId) {
        nodeStatus[nodeId] = !nodeStatus[nodeId];
        const status = nodeStatus[nodeId] ? "active" : "inactive";
        addLogEntry(`Node ${nodeId.replace("node", "PC ")} is now <span class="${status}-connection">${status.toUpperCase()}</span>`, "info");
        updateVisuals();
      }

      function toggleHub() {
        hubActive = !hubActive;
        document.getElementById("toggleHub").textContent = `Toggle Hub (${
          hubActive ? "ON" : "OFF"
        })`;
        const status = hubActive ? "active" : "inactive";
        addLogEntry(`Hub is now <span class="${status}-connection">${status.toUpperCase()}</span>`, hubActive ? "info" : "error");
        updateVisuals();
      }

      function resetAll() {
        hubActive = true;
        for (let id in nodeStatus) nodeStatus[id] = true;
        document.getElementById("toggleHub").textContent = `Toggle Hub (ON)`;
        addLogEntry("All nodes and hub have been reset to <span class=\"active-connection\">ACTIVE</span>", "info");
        updateVisuals();
      }

      function updateVisuals() {
        // Update hub visual state
        const hubNode = data.nodes.get("hub");
        if (hubActive) {
          hubNode.borderWidth = 4;
          hubNode.borderWidthSelected = 4;
          hubNode.color = { border: HUB_ACTIVE };
          hubNode.shadowColor = HUB_ACTIVE;
        } else {
          hubNode.borderWidth = 4;
          hubNode.borderWidthSelected = 4;
          hubNode.color = { border: HUB_INACTIVE };
          hubNode.shadowColor = HUB_INACTIVE;
        }
        data.nodes.update(hubNode);

        // Update each node's visual state
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          if (!data.nodes.get(nodeId)) continue; // Skip if node doesn't exist
          
          const edgeId = `edge${i}`;
          const active = nodeStatus[nodeId] && hubActive;

          // Update node appearance
          const node = data.nodes.get(nodeId);
          node.borderWidth = 4;
          node.borderWidthSelected = 4;
          node.color = {
            border: nodeStatus[nodeId] ? NODE_ACTIVE : NODE_INACTIVE,
          };
          node.shadowColor = nodeStatus[nodeId] ? NODE_ACTIVE : NODE_INACTIVE;
          data.nodes.update(node);

          // Update edge appearance and incorporate traffic data
          const trafficLevel = getTrafficLevel(nodeId);
          let edgeWidth = 2;
          
          // Adjust edge width based on traffic
          if (trafficLevel === 'medium') edgeWidth = 3;
          if (trafficLevel === 'high') edgeWidth = 4;
          
          data.edges.update({
            id: edgeId,
            color: {
              color: active ? "#000000" : "#E53935",
              opacity: 1,
            },
            width: edgeWidth,
            dashes: !active, // dashes for inactive connections
            title: `Traffic: ${trafficData[nodeId].packetsSent + trafficData[nodeId].packetsReceived} packets`
          });
        }

        updateStatusText();

        // Force blinking to restart after updating visuals
        if (blinkInterval) {
          clearInterval(blinkInterval);
          blinkInactiveEdges();
        }
      }

      // Get traffic level for a node connection
      function getTrafficLevel(nodeId) {
        if (!trafficData[nodeId]) return 'low';
        
        const totalPackets = trafficData[nodeId].packetsSent + trafficData[nodeId].packetsReceived;
        const timeSinceStart = (Date.now() - trafficData[nodeId].lastUpdate) / 1000;
        
        // Reset traffic if it's been a while
        if (timeSinceStart > 60) {
          trafficData[nodeId].packetsSent = 0;
          trafficData[nodeId].packetsReceived = 0;
          trafficData[nodeId].lastUpdate = Date.now();
          return 'low';
        }
        
        // Calculate packets per second
        const packetsPerSecond = totalPackets / Math.max(timeSinceStart, 1);
        
        if (packetsPerSecond > 0.5) return 'high';
        if (packetsPerSecond > 0.2) return 'medium';
        return 'low';
      }

      function updateStatusText() {
        const statusEl = document.getElementById("status");
        if (!hubActive) {
          statusEl.innerHTML =
            'Hub is <span class="inactive-connection">OFF</span> - All connections inactive';
          return;
        }

        const activeCount = Object.keys(nodeStatus)
          .filter(id => parseInt(id.replace('node', '')) <= nodeCount) // Only consider existing nodes
          .filter(id => nodeStatus[id]).length;
        
        if (activeCount === nodeCount) {
          statusEl.innerHTML =
            'All connections <span class="active-connection">ACTIVE</span>';
        } else if (activeCount === 0) {
          statusEl.innerHTML =
            'All nodes <span class="inactive-connection">INACTIVE</span>';
        } else {
          statusEl.innerHTML = `<span class="active-connection">${activeCount}</span> active, <span class="inactive-connection">${
            nodeCount - activeCount
          }</span> inactive`;
        }
      }

      function blinkInactiveEdges() {
        let toggle = false;
        clearInterval(blinkInterval);
        blinkInterval = setInterval(() => {
          for (let i = 1; i <= nodeCount; i++) {
            const nodeId = `node${i}`;
            const edgeId = `edge${i}`;
            
            // Skip if node or edge doesn't exist
            if (!data.nodes.get(nodeId) || !data.edges.get(edgeId)) continue;
            
            const active = nodeStatus[nodeId] && hubActive;

            if (!active) {
              // For inactive connections, blink the edges
              data.edges.update({
                id: edgeId,
                color: { color: toggle ? "#E53935" : "#FF0000" }, // Dark red to bright red blink
                dashes: true,
                width: toggle ? 2 : 3, // Slightly change width for more visible blinking
              });
            }
          }
          toggle = !toggle;
        }, 500);
      }

      // Animate packet along a path with requestAnimationFrame for smooth motion
      function animatePacketAlongPath(x1, y1, x2, y2, centerX, centerY, onComplete) {
        const networkDiv = document.getElementById('network');
        if (!networkDiv) {
          console.error("Network div not found");
          if (onComplete) onComplete();
          return;
        }
        
        const packet = createPacketElement();
        packetElements.push(packet);

        // Use #network's center for calculations
        const startX = (networkDiv.clientWidth / 2) + x1;
        const startY = (networkDiv.clientHeight / 2) + y1;
        const endX = (networkDiv.clientWidth / 2) + x2;
        const endY = (networkDiv.clientHeight / 2) + y2;

        // Duration in milliseconds
        const duration = PACKET_SPEED;
        const startTime = performance.now();
        
        // Setup for trailing effect
        const trailInterval = 100; // ms between trail elements
        let lastTrailTime = 0;
        
        // Animation function
        function animate(currentTime) {
          // Safety check if we exited the animation early
          if (!packet.parentNode) {
            if (onComplete) onComplete();
            return;
          }
          
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Ease in-out function for smoother movement
          const easedProgress = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          // Calculate current position
          const currentX = startX + (endX - startX) * easedProgress;
          const currentY = startY + (endY - startY) * easedProgress;
          
          // Set packet position
          packet.style.left = `${currentX}px`;
          packet.style.top = `${currentY}px`;
          
          // Create trail effect
          if (currentTime - lastTrailTime > trailInterval && progress > 0.1 && progress < 0.9) {
            lastTrailTime = currentTime;
            const trail = createTrailElement();
            trail.style.left = `${currentX}px`;
            trail.style.top = `${currentY}px`;
            packetElements.push(trail);
            
            // Fade out and remove trail element
            setTimeout(() => {
              if (trail && trail.parentNode) {
                trail.style.opacity = '0';
                setTimeout(() => {
                  if (trail && trail.parentNode) trail.parentNode.removeChild(trail);
                  const index = packetElements.indexOf(trail);
                  if (index !== -1) packetElements.splice(index, 1);
                }, 300);
              }
            }, 200);
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Animation complete
            setTimeout(() => {
              if (packet && packet.parentNode) packet.parentNode.removeChild(packet);
              const index = packetElements.indexOf(packet);
              if (index !== -1) packetElements.splice(index, 1);
              
              if (onComplete) onComplete();
            }, 100);
          }
        }
        
        // Start animation
        requestAnimationFrame(animate);
      }
      
      // Create visual packet
      function createPacketElement() {
        const packet = document.createElement('div');
        packet.className = 'packet';
        const networkDiv = document.querySelector('#network');
        if (networkDiv) {
          networkDiv.appendChild(packet);
        }
        return packet;
      }
      
      // Create packet trail
      function createTrailElement() {
        const trail = document.createElement('div');
        trail.className = 'packet-trail';
        const networkDiv = document.querySelector('#network');
        if (networkDiv) {
          networkDiv.appendChild(trail);
        }
        return trail;
      }
      
      // Clean up visual elements
      function cleanupPacketElements() {
        packetElements.forEach(element => {
          if (element && element.parentNode) {
            element.parentNode.removeChild(element);
          }
        });
        packetElements = [];
      }
      
      // Add pulse effect to a node
      function pulseEffect(nodeId) {
        const positions = network.getPositions([nodeId]);
        if (!positions || !positions[nodeId]) {
          console.error("Node position not found:", nodeId);
          return;
        }
        
        const nodePosition = positions[nodeId];
        const networkDiv = document.getElementById('network');
        if (!networkDiv) return;
        
        const rect = networkDiv.getBoundingClientRect();

        // Calculate position relative to #network
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const x = centerX + nodePosition.x;
        const y = centerY + nodePosition.y;

        // Create pulse element
        const pulse = document.createElement('div');
        pulse.className = 'packet pulse-effect';
        pulse.style.left = `${x}px`;
        pulse.style.top = `${y}px`;
        networkDiv.appendChild(pulse);
        packetElements.push(pulse);

        // Remove after animation completes
        setTimeout(() => {
          if (pulse && pulse.parentNode) pulse.parentNode.removeChild(pulse);
          const index = packetElements.indexOf(pulse);
          if (index !== -1) packetElements.splice(index, 1);
        }, 500);
      }

      // Initialize configuration controls
      function initConfigControls() {
        // Latency slider
        const latencySlider = document.getElementById('latencySlider');
        const latencyValue = document.getElementById('latencyValue');
        
        latencySlider.addEventListener('input', function() {
          currentLatency = parseInt(this.value);
          latencyValue.textContent = currentLatency;
        });
        
        // Packet size slider
        const packetSizeSlider = document.getElementById('packetSizeSlider');
        const packetSizeValue = document.getElementById('packetSizeValue');
        
        packetSizeSlider.addEventListener('input', function() {
          currentPacketSize = parseInt(this.value);
          packetSizeValue.textContent = currentPacketSize;
        });
        
        // Load test packets slider
        const loadTestPackets = document.getElementById('loadTestPackets');
        const loadTestPacketsValue = document.getElementById('loadTestPacketsValue');
        
        loadTestPackets.addEventListener('input', function() {
          loadTestPacketsValue.textContent = this.value;
        });
        
        // Load test button
        document.getElementById('runLoadTest').addEventListener('click', runLoadTest);
        
        // Collision detection toggle
        const enableCollisionsCheckbox = document.getElementById('enableCollisions');
        enableCollisionsCheckbox.addEventListener('change', function() {
          enableCollisions = this.checked;
        });
      }
      
      // Function to run a load test
      function runLoadTest() {
        if (isAnimatingPacket) {
          addLogEntry("Cannot start load test while packets are being animated", "error");
          return;
        }
        
        // Get number of packets to send
        const numPackets = parseInt(document.getElementById('loadTestPackets').value);
        
        // Get all active nodes
        const activeNodes = [];
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          if (nodeStatus[nodeId] && hubActive) {
            activeNodes.push(nodeId);
          }
        }
        
        // Need at least 2 active nodes
        if (activeNodes.length < 2) {
          addLogEntry("Load test requires at least 2 active nodes", "error");
          return;
        }
        
        // Reset metrics
        loadTestMetrics = {
          packetsSent: 0,
          packetsDelivered: 0,
          collisions: 0,
          deliveryTimes: [],
          startTime: Date.now()
        };
        
        // Show results panel
        document.getElementById('loadTestResults').style.display = 'block';
        updateLoadTestMetrics();
        
        // Queue up packets
        for (let i = 0; i < numPackets; i++) {
          // Random source and target
          let source, target;
          do {
            source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
            target = activeNodes[Math.floor(Math.random() * activeNodes.length)];
          } while (source === target);
          
          // Create packet data
          const packetData = {
            id: 'packet-' + Date.now() + '-' + i,
            source: source,
            target: target,
            size: currentPacketSize,
            creationTime: Date.now() + (i * 100) // Stagger creation times
          };
          
          // Add to queue
          packetQueue.push(packetData);
          
          // Update queue visualization
          updateQueueVisualization();
          
          // Update metrics
          loadTestMetrics.packetsSent++;
          updateLoadTestMetrics();
        }
        
        // Start processing the queue
        addLogEntry(`Load test started with ${numPackets} packets`, "info");
        processPacketQueue();
      }
      
      // Process packets from the queue
      function processPacketQueue() {
        if (packetQueue.length === 0 || !hubActive) {
          return;
        }
        
        // If not currently animating, process next packet
        if (!isAnimatingPacket) {
          const nextPacket = packetQueue.shift();
          updateQueueVisualization();
          
          // Send the packet
          sendPacketWithData(nextPacket);
        }
        
        // Use setTimeout instead of direct recursion to prevent stack overflow
        setTimeout(processPacketQueue, 100);
      }
      
      // Update queue visualization
      function updateQueueVisualization() {
        // No-op function since the queue visualization has been removed 
        // but we keep it for backward compatibility with existing code
        return;
      }
      
      // Update load test metrics display
      function updateLoadTestMetrics() {
        document.getElementById('metricSent').textContent = loadTestMetrics.packetsSent;
        document.getElementById('metricDelivered').textContent = loadTestMetrics.packetsDelivered;
        document.getElementById('metricCollisions').textContent = loadTestMetrics.collisions;
        
        // Calculate average delivery time
        let avgTime = 0;
        if (loadTestMetrics.deliveryTimes.length > 0) {
          avgTime = loadTestMetrics.deliveryTimes.reduce((sum, time) => sum + time, 0) / 
                   loadTestMetrics.deliveryTimes.length;
        }
        document.getElementById('metricTime').textContent = Math.round(avgTime) + ' ms';
      }
      
      // Enhanced send packet function with packet data
      function sendPacketWithData(packetData) {
        const source = packetData.source;
        const target = packetData.target;
        const packetSize = packetData.size;
        const creationTime = packetData.creationTime || Date.now();
        
        // Basic validation
        if (!source || !target || source === target || !hubActive || !nodeStatus[source] || !nodeStatus[target]) {
          // Skip invalid packets
          if (packetQueue.length > 0) {
            // If we're processing from the queue, continue with next packet
            isAnimatingPacket = false;
            setTimeout(processPacketQueue, 100);
          }
          return;
        }
        
        // Additional check if nodes still exist in the network
        try {
          if (!data.nodes.get(source) || !data.nodes.get(target)) {
            addLogEntry(`Packet transmission failed: Source or target node doesn't exist`, "error");
            
            // Continue with next packet if in queue
            if (packetQueue.length > 0) {
              isAnimatingPacket = false;
              setTimeout(processPacketQueue, 100);
            }
            return;
          }
        } catch (e) {
          console.error("Error checking node existence:", e);
          
          // Continue with next packet if in queue
          if (packetQueue.length > 0) {
            isAnimatingPacket = false;
            setTimeout(processPacketQueue, 100);
          }
          return;
        }
        
        const packetStatusEl = document.getElementById("packetStatus");
        packetStatusEl.innerHTML = `<span class="active-connection">Sending ${packetSize}B packet from ${source.replace(
          "node", "PC "
        )} to ${target.replace("node", "PC ")}</span>`;
        
        addLogEntry(`Sending ${packetSize}B packet from ${source.replace("node", "PC ")} to ${target.replace("node", "PC ")}`, "source");
        
        // Track traffic
        trafficData[source].packetsSent++;
        trafficData[target].packetsReceived++;
        
        isAnimatingPacket = true;
        
        // Temporarily pause blinking during animation
        clearInterval(blinkInterval);
        
        // Clean up any existing packet elements
        cleanupPacketElements();
        
        // Add pulse effect to source node
        pulseEffect(source);
        
        // Register this packet as active
        const packetId = 'packet-' + Date.now();
        activePackets.push({
          id: packetId,
          source: source,
          target: target,
          creationTime: creationTime,
          size: packetSize,
          path: [source, 'hub', target],
          currentSegment: 0 // Starting with source → hub
        });
        
        // Animate the packet with size and latency considerations
        setTimeout(() => {
          animatePacketWithParams(source, target, packetId, packetSize);
        }, 300);
      }
      
      // Check for packet collisions
      function checkCollisions(packetId, position) {
        if (!enableCollisions) return false;
        
        // Get the current packet
        const currentPacket = activePackets.find(p => p.id === packetId);
        if (!currentPacket) return false;
        
        // Check all other active packets for collision at similar position
        for (const packet of activePackets) {
          // Skip self
          if (packet.id === packetId) continue;
          
          // Ensure both packets have current positions and segments
          const otherPosition = packet.currentPosition;
          if (!otherPosition || 
              typeof packet.currentSegment === 'undefined' || 
              typeof currentPacket.currentSegment === 'undefined' ||
              !packet.path || 
              !currentPacket.path) continue;
          
          // Skip if path segments don't exist
          if (packet.currentSegment >= packet.path.length ||
              currentPacket.currentSegment >= currentPacket.path.length) continue;
          
          // Distance calculation (simple Euclidean)
          const dx = position.x - otherPosition.x;
          const dy = position.y - otherPosition.y;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          // If packets are close and on the same segment, collision occurred
          if (distance < 30 && 
              packet.path[packet.currentSegment] === currentPacket.path[currentPacket.currentSegment]) {
            
            // Create collision effect
            createCollisionEffect(position.x, position.y);
            
            // Update metrics
            loadTestMetrics.collisions++;
            collisionCount++;
            updateLoadTestMetrics();
            
            addLogEntry(`Collision detected between packets from ${currentPacket.source.replace('node', 'PC ')} and ${packet.source.replace('node', 'PC ')}`, "error");
            
            return true;
          }
        }
        
        return false;
      }
      
      // Create visual collision effect
      function createCollisionEffect(x, y) {
        const networkDiv = document.getElementById('network');
        if (!networkDiv) return;
        
        const collision = document.createElement('div');
        collision.className = 'packet collision-effect';
        collision.style.left = `${x}px`;
        collision.style.top = `${y}px`;
        networkDiv.appendChild(collision);
        packetElements.push(collision);
        
        // Remove after animation completes
        setTimeout(() => {
          if (collision && collision.parentNode) collision.parentNode.removeChild(collision);
          const index = packetElements.indexOf(collision);
          if (index !== -1) packetElements.splice(index, 1);
        }, 600);
      }
      
      // Enhanced animation function with packet size and latency
      function animatePacketWithParams(source, target, packetId, packetSize) {
        // Get positions for source, hub, and target
        const positions = network.getPositions([source, "hub", target]);
        const sourcePos = positions[source];
        const hubPos = positions["hub"];
        const targetPos = positions[target];
        
        // Get DOM positions from network positions
        const canvas = document.querySelector('#network canvas');
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + (rect.width / 2);
        const centerY = rect.top + (rect.height / 2);
        
        // Calculate packet speed based on size (larger packets travel slower)
        // 64 bytes is baseline speed, 1500 bytes is ~2x slower
        const sizeSpeedFactor = 1 + ((packetSize - 64) / 1436);
        const adjustedSpeed = PACKET_SPEED * sizeSpeedFactor;
        
        // Step 1: Animate from source to hub with added latency
        addLogEntry(`Packet traveling from ${source.replace("node", "PC ")} to hub`, "info");
        
        // Find the packet in active packets and update its segment
        const packetIndex = activePackets.findIndex(p => p.id === packetId);
        if (packetIndex !== -1) {
          activePackets[packetIndex].currentSegment = 0; // source → hub
        }
        
        animatePacketAlongPathWithLatency(
          sourcePos.x, sourcePos.y,
          hubPos.x, hubPos.y,
          centerX, centerY,
          packetId, packetSize,
          adjustedSpeed,
          () => {
            // Update packet segment
            if (packetIndex !== -1) {
              activePackets[packetIndex].currentSegment = 1; // hub → target
            }
            
            // Add pulse effect to hub
            pulseEffect("hub");
            addLogEntry(`Packet arrived at hub, processing routing (added latency: ${currentLatency}ms)`, "info");
            
            // Step 2: After reaching hub, apply latency then animate to target
            setTimeout(() => {
              addLogEntry(`Packet traveling from hub to ${target.replace("node", "PC ")}`, "info");
              animatePacketAlongPathWithLatency(
                hubPos.x, hubPos.y,
                targetPos.x, targetPos.y,
                centerX, centerY,
                packetId, packetSize,
                adjustedSpeed,
                () => {
                  // Add pulse effect to target node
                  pulseEffect(target);
                  
                  // Update status
                  document.getElementById("packetStatus").innerHTML = 
                    `<span class="active-connection">Packet successfully delivered from ${source.replace(
                      "node", "PC "
                    )} to ${target.replace("node", "PC ")}</span>`;
                  
                  addLogEntry(`Packet successfully delivered to ${target.replace("node", "PC ")} (${ipConfigurations[target] || generateIP(parseInt(target.replace("node", "")))})`, "target");
                  
                  // Record delivery metrics
                  const deliveryTime = Date.now() - (activePackets[packetIndex]?.creationTime || Date.now());
                  loadTestMetrics.deliveryTimes.push(deliveryTime);
                  loadTestMetrics.packetsDelivered++;
                  updateLoadTestMetrics();
                  
                  // Remove packet from active packets
                  if (packetIndex !== -1) {
                    activePackets.splice(packetIndex, 1);
                  }
                  
                  // Animation complete
                  isAnimatingPacket = false;
                  
                  // Restart blinking for inactive edges
                  blinkInactiveEdges();
                  
                  // Update visuals to reflect traffic changes
                  updateVisuals();
                  
                  // Process next packet in queue if any
                  if (packetQueue.length > 0) {
                    processPacketQueue();
                  }
                }
              );
            }, currentLatency); // Apply configured latency
          }
        );
      }

      // Animate packet along a path with size and latency considerations
      function animatePacketAlongPathWithLatency(x1, y1, x2, y2, centerX, centerY, packetId, packetSize, duration, onComplete) {
        const networkDiv = document.getElementById('network');
        if (!networkDiv) {
          console.error("Network div not found");
          if (onComplete) onComplete();
          return;
        }
        
        // Create packet with size considerations
        const packet = createPacketElement(packetSize);
        packetElements.push(packet);

        // Use #network's center for calculations
        const startX = (networkDiv.clientWidth / 2) + x1;
        const startY = (networkDiv.clientHeight / 2) + y1;
        const endX = (networkDiv.clientWidth / 2) + x2;
        const endY = (networkDiv.clientHeight / 2) + y2;
        
        // Start time
        const startTime = performance.now();
        
        // Setup for trailing effect (more trails for larger packets)
        const trailInterval = Math.max(50, 120 - packetSize/20); // ms between trail elements
        let lastTrailTime = 0;
        
        // Animation function
        function animate(currentTime) {
          // Safety check if we exited the animation early
          if (!packet.parentNode) {
            if (onComplete) onComplete();
            return;
          }
          
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Ease in-out function for smoother movement
          const easedProgress = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          // Calculate current position
          const currentX = startX + (endX - startX) * easedProgress;
          const currentY = startY + (endY - startY) * easedProgress;
          
          // Set packet position
          packet.style.left = `${currentX}px`;
          packet.style.top = `${currentY}px`;
          
          // Update packet position in activePackets array
          const packetIndex = activePackets.findIndex(p => p.id === packetId);
          if (packetIndex !== -1) {
            activePackets[packetIndex].currentPosition = { x: currentX, y: currentY };
          }
          
          // Check for collisions
          if (enableCollisions) {
            const hasCollision = checkCollisions(packetId, { x: currentX, y: currentY });
            if (hasCollision) {
              // Stop animation and clean up
              if (packet && packet.parentNode) packet.parentNode.removeChild(packet);
              const index = packetElements.indexOf(packet);
              if (index !== -1) packetElements.splice(index, 1);
              
              // Remove from active packets
              if (packetIndex !== -1) {
                activePackets.splice(packetIndex, 1);
              }
              
              // Reset animation state
              isAnimatingPacket = false;
              
              // Process next packet in queue
              if (packetQueue.length > 0) {
                processPacketQueue();
              }
              
              return; // Exit animation
            }
          }
          
          // Create trail effect
          if (currentTime - lastTrailTime > trailInterval && progress > 0.1 && progress < 0.9) {
            lastTrailTime = currentTime;
            const trail = createTrailElement(packetSize);
            trail.style.left = `${currentX}px`;
            trail.style.top = `${currentY}px`;
            packetElements.push(trail);
            
            // Fade out and remove trail element
            setTimeout(() => {
              if (trail && trail.parentNode) {
                trail.style.opacity = '0';
                setTimeout(() => {
                  if (trail && trail.parentNode) trail.parentNode.removeChild(trail);
                  const index = packetElements.indexOf(trail);
                  if (index !== -1) packetElements.splice(index, 1);
                }, 300);
              }
            }, 200);
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Animation complete
            setTimeout(() => {
              if (packet && packet.parentNode) packet.parentNode.removeChild(packet);
              const index = packetElements.indexOf(packet);
              if (index !== -1) packetElements.splice(index, 1);
              
              if (onComplete) onComplete();
            }, 100);
          }
        }
        
        // Start animation
        requestAnimationFrame(animate);
      }
      
      // Create visual packet with size considerations
      function createPacketElement(packetSize = 64) {
        const packet = document.createElement('div');
        packet.className = 'packet';
        
        // Adjust size based on packet size
        const sizeMultiplier = 0.7 + (packetSize / 1500) * 0.8; // 0.7-1.5x size
        const baseSize = 18; // Base size in pixels
        const size = Math.round(baseSize * sizeMultiplier);
        
        packet.style.width = `${size}px`;
        packet.style.height = `${size}px`;
        
        const networkDiv = document.querySelector('#network');
        if (networkDiv) {
          networkDiv.appendChild(packet);
        }
        return packet;
      }
      
      // Create packet trail with size considerations
      function createTrailElement(packetSize = 64) {
        const trail = document.createElement('div');
        trail.className = 'packet-trail';
        
        // Adjust size based on packet size
        const sizeMultiplier = 0.7 + (packetSize / 1500) * 0.8; // 0.7-1.5x size
        const baseSize = 8; // Base size in pixels
        const size = Math.round(baseSize * sizeMultiplier);
        
        trail.style.width = `${size}px`;
        trail.style.height = `${size}px`;
        
        const networkDiv = document.querySelector('#network');
        if (networkDiv) {
          networkDiv.appendChild(trail);
        }
        return trail;
      }

      /**
       * Initiates packet sending based on user selection
       * Handles both unicast and broadcast modes
       */
      function sendPacket() {
        const source = document.getElementById("sourceNode").value;
        const target = document.getElementById("targetNode").value;
        const packetMode = document.querySelector('input[name="packetMode"]:checked').value;
        
        if (isAnimatingPacket) {
          addLogEntry("Cannot send packet while another packet is being animated", "error");
          return;
        }

        if (!source) {
          addLogEntry("Please select a source node", "error");
          return;
        }

        if (packetMode === "unicast" && !target) {
          addLogEntry("Please select a target node for unicast transmission", "error");
          return;
        }

        if (source === target && packetMode === "unicast") {
          addLogEntry("Source and target nodes cannot be the same", "error");
          return;
        }

        if (packetMode === "unicast") {
          // Use retry logic for unicast transmissions
          sendPacketWithRetry(source, target);
        } else if (packetMode === "broadcast") {
          // Prevent broadcast spam
          const now = Date.now();
          if (now - lastBroadcastTime < 3000) {
            addLogEntry("Please wait before sending another broadcast", "error");
            return;
          }
          lastBroadcastTime = now;
          
          broadcastPacket(source);
        }
      }
      
      /**
       * Implements packet transmission retry logic
       * In case of delivery failure, attempts to retransmit the packet
       * @param {string} source - Source node ID
       * @param {string} target - Target node ID
       * @param {number} attempts - Number of retry attempts left
       */
      function sendPacketWithRetry(source, target, attempts = 3) {
        // Check if transmission is possible
        if (!canTransmit(source, target)) {
          if (attempts > 0) {
            addLogEntry(`Transmission failed, retrying... (${attempts} attempts left)`, "error");
            
            // Wait and retry with reduced attempts count
            setTimeout(() => {
              sendPacketWithRetry(source, target, attempts - 1);
            }, 1000);
          } else {
            addLogEntry("Packet delivery failed after multiple attempts", "error");
            document.getElementById("packetStatus").innerHTML = 
              '<span class="inactive-connection">DELIVERY FAILED</span>';
          }
          return;
        }
        
        // If transmission is possible, send the packet
        sendPacketBetweenNodes(source, target);
      }
      
      /**
       * Checks if packet transmission is possible between nodes
       * In a star topology, both nodes and the hub must be active
       * @param {string} source - Source node ID
       * @param {string} target - Target node ID
       * @returns {boolean} - Whether transmission is possible
       */
      function canTransmit(source, target) {
        // Verify hub is active (central to star topology)
        if (!hubActive) {
          addLogEntry("Cannot transmit: Hub is inactive", "error");
          return false;
        }
        
        // Verify source node is active
        if (!nodeStatus[source]) {
          addLogEntry(`Cannot transmit: Source ${source.replace("node", "PC ")} is inactive`, "error");
          return false;
        }
        
        // Verify target node is active
        if (!nodeStatus[target]) {
          addLogEntry(`Cannot transmit: Target ${target.replace("node", "PC ")} is inactive`, "error");
          return false;
        }
        
        return true;
      }

      /**
       * Simulates packet transmission between nodes in a star topology
       * All communication must go through the central hub
       * @param {string} source - Source node ID
       * @param {string} target - Target node ID
       * @param {number} packetSize - Size of the packet in bytes 
       */
      function sendPacketBetweenNodes(source, target, packetSize = currentPacketSize) {
        const packetStatusEl = document.getElementById("packetStatus");
        
        // Create packet data
        const packetData = {
          id: 'packet-' + Date.now(),
          source: source,
          target: target,
          size: packetSize,
          creationTime: Date.now()
        };
        
        addLogEntry(`Sending packet from ${source.replace("node", "PC ")} to ${target.replace("node", "PC ")}`, "source");
        packetStatusEl.innerHTML = `<span class="active-connection">Sending packet from ${source.replace("node", "PC ")} to ${target.replace("node", "PC ")}</span>`;
        
        // Track traffic
        trafficData[source].packetsSent++;
        trafficData[target].packetsReceived++;
        
        isAnimatingPacket = true;
        
        // Temporarily pause blinking during animation
        clearInterval(blinkInterval);
        
        // Clean up any existing packet elements
        cleanupPacketElements();
        
        // Add pulse effect to source node
        pulseEffect(source);
        
        // Register this packet as active
        const packetId = packetData.id;
        const creationTime = packetData.creationTime;
        activePackets.push({
          id: packetId,
          source: source,
          target: target,
          creationTime: creationTime,
          size: packetSize,
          path: [source, 'hub', target],
          currentSegment: 0 // Starting with source → hub
        });
        
        // Animate the packet with size and latency considerations
        setTimeout(() => {
          animatePacketWithParams(source, target, packetId, packetSize);
        }, 300);
      }

      // New function to handle broadcast packet sending
      function broadcastPacket(source = null) {
        // If source isn't provided, get it from the select
        if (!source) {
          const sourceSelect = document.getElementById("sourceNode");
          source = sourceSelect.value;
        }
        
        if (!source) {
          addLogEntry("Please select a source node for broadcast", "error");
          return;
        }
        
        if (isAnimatingPacket) {
          addLogEntry("Cannot broadcast while another packet is being animated", "error");
          return;
        }
        
        if (!hubActive) {
          addLogEntry("Cannot broadcast: Hub is inactive", "error");
          return;
        }
        
        if (!nodeStatus[source]) {
          addLogEntry(`Cannot broadcast: Source ${source.replace("node", "PC ")} is inactive`, "error");
          return;
        }
        
        // Create list of valid target nodes (active and not the source)
        const targets = [];
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          // Skip the source node and inactive nodes
          if (nodeId !== source && nodeStatus[nodeId]) {
            targets.push(nodeId);
          }
        }
        
        if (targets.length === 0) {
          addLogEntry("No active target nodes available for broadcast", "error");
          return;
        }
        
        // Show broadcast message
        const packetStatusEl = document.getElementById("packetStatus");
        packetStatusEl.innerHTML = `<span class="active-connection">Broadcasting from ${source.replace("node", "PC ")} to all nodes</span>`;
        addLogEntry(`Broadcasting from ${source.replace("node", "PC ")} to all nodes`, "source");
        
        // Create a unique ID for this broadcast
        const broadcastId = 'broadcast-' + Date.now();
        
        isAnimatingPacket = true;
        
        // Temporarily pause blinking during animation
        clearInterval(blinkInterval);
        
        // Clean up any existing packet elements
        cleanupPacketElements();
        
        // Animate the broadcast
        animateBroadcastWithParams(source, targets, broadcastId, currentPacketSize);
      }
      
      function animateBroadcastWithParams(source, targets, basePacketId, packetSize) {
        // Get positions for source, hub, and all targets
        const nodeIds = [source, "hub", ...targets];
        const positions = network.getPositions(nodeIds);
        
        // Track traffic for broadcast
        trafficData[source].packetsSent += targets.length;
        targets.forEach(target => {
          if (trafficData[target]) {
            trafficData[target].packetsReceived++;
          }
        });
        
        // Canvas coordinates for center reference
        const canvas = document.querySelector('#network canvas');
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + (rect.width / 2);
        const centerY = rect.top + (rect.height / 2);
        
        // Calculate packet speed based on size
        const sizeSpeedFactor = 1 + ((packetSize - 64) / 1436);
        const adjustedSpeed = PACKET_SPEED * sizeSpeedFactor;
        
        // First animate from source to hub
        animatePacketAlongPathWithLatency(
          positions[source].x, positions[source].y,
          positions["hub"].x, positions["hub"].y,
          centerX, centerY,
          basePacketId + '-source', packetSize,
          adjustedSpeed,
          () => {
            // Add pulse effect to hub
            pulseEffect("hub");
            addLogEntry(`Packet arrived at hub, processing broadcast routing (added latency: ${currentLatency}ms)`, "info");
            
            // After latency, send to all targets
            setTimeout(() => {
              // Create a sequence of animations (hub to each target)
              let animationSequence = Promise.resolve();
              
              // Use a delay multiple
              const delayMultiple = 200;
              
              // Register all target packets
              targets.forEach((target, index) => {
                // Check if target still exists
                if (!positions[target]) return;
                
                // Create packet for this target
                activePackets.push({
                  id: basePacketId + '-target-' + index,
                  source: 'hub',
                  target: target,
                  creationTime: Date.now() + (index * delayMultiple),
                  size: packetSize,
                  path: ['hub', target],
                  currentSegment: 0
                });
              });
              
              // Then animate from hub to each target with staggered timing
              targets.forEach((target, index) => {
                // Check if target still exists
                if (!positions[target]) return;
                
                animationSequence = animationSequence.then(() => {
                  return new Promise(resolve => {
                    setTimeout(() => {
                      addLogEntry(`Broadcasting to ${target.replace("node", "PC ")}`, "info");
                      animatePacketAlongPathWithLatency(
                        positions["hub"].x, positions["hub"].y,
                        positions[target].x, positions[target].y,
                        centerX, centerY,
                        basePacketId + '-target-' + index, packetSize,
                        adjustedSpeed,
                        () => {
                          // Add pulse effect to target node
                          pulseEffect(target);
                          
                          // Record delivery metrics
                          const deliveryTime = Date.now() - activePackets[0]?.creationTime;
                          loadTestMetrics.deliveryTimes.push(deliveryTime);
                          loadTestMetrics.packetsDelivered++;
                          updateLoadTestMetrics();
                          
                          addLogEntry(`Packet delivered to ${target.replace("node", "PC ")} (${ipConfigurations[target] || generateIP(parseInt(target.replace("node", "")))})`, "target");
                          resolve();
                        }
                      );
                    }, index * delayMultiple);
                  });
                });
              });
              
              // When all animations complete
              animationSequence.then(() => {
                document.getElementById("packetStatus").innerHTML = 
                  `<span class="active-connection">Broadcast successfully delivered from ${source.replace(
                    "node", "PC "
                  )} to ${targets.length} nodes</span>`;
                  
                // Clear active packets safely
                activePackets = activePackets.filter(p => !p.id.startsWith(basePacketId));
                  
                // Animation complete
                isAnimatingPacket = false;
                
                // Restart blinking for inactive edges
                blinkInactiveEdges();
                
                // Update visuals to reflect traffic changes
                updateVisuals();
                
                // Process next packet in queue if any
                if (packetQueue.length > 0) {
                  setTimeout(processPacketQueue, 100);
                }
              });
            }, currentLatency);
          }
        );
      }

      // Add a new node to the network
      function addNode() {
        // Stop any ongoing animations
        if (isAnimatingPacket) {
          cleanupPacketElements();
          isAnimatingPacket = false;
        }
        
        nodeCount++;
        const newNodeId = `node${nodeCount}`;
        
        // Initialize node status and traffic data
        nodeStatus[newNodeId] = true;
        trafficData[newNodeId] = {
          packetsSent: 0,
          packetsReceived: 0,
          lastUpdate: Date.now()
        };
        
        // Add new IP to configurations if needed
        if (!ipConfigurations[newNodeId]) {
          ipConfigurations[newNodeId] = generateIP(nodeCount);
        }
        
        // Rebuild the network with the new node count
        createNetwork();
        addLogEntry(`Added new node: PC ${nodeCount} (${ipConfigurations[newNodeId]})`, "info");
        
        // Update visuals
        updateVisuals();
      }
      
      // Remove the last node from the network
      function removeNode() {
        if (nodeCount <= 2) {
          addLogEntry("Cannot remove node: Minimum 2 nodes required", "error");
          return;
        }
        
        // Stop any ongoing animations
        if (isAnimatingPacket) {
          cleanupPacketElements();
          isAnimatingPacket = false;
        }
        
        const removedNodeId = `node${nodeCount}`;
        addLogEntry(`Removed node: PC ${nodeCount} (${ipConfigurations[removedNodeId] || generateIP(nodeCount)})`, "info");
        
        // Clean up node status and traffic data
        delete nodeStatus[removedNodeId];
        delete trafficData[removedNodeId];
        
        // Decrement node count and rebuild network
        nodeCount--;
        createNetwork();
        
        // Update visuals
        updateVisuals();
      }

      // New function for auto simulation
      function autoSimulate() {
        const button = document.getElementById("autoSimulate");
        
        if (autoSimulateInterval) {
          // Stop auto simulation
          clearInterval(autoSimulateInterval);
          autoSimulateInterval = null;
          button.textContent = "Auto Simulate";
          addLogEntry("Auto simulation stopped", "info");
          return;
        }
        
        // Start auto simulation
        button.textContent = "Stop Auto Simulate";
        addLogEntry("Auto simulation started", "info");
        
        // Run the first simulation immediately
        runOneSimulation();
        
        autoSimulateInterval = setInterval(runOneSimulation, PACKET_SPEED * 3);
      }
      
      // Helper function to run a single simulation step
      function runOneSimulation() {
        if (isAnimatingPacket) return; // Don't start new animation if one is in progress
        
        // Get all active nodes
        const activeNodes = [];
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          if (nodeStatus[nodeId] && hubActive) {
            activeNodes.push(nodeId);
          }
        }
        
        // If less than 2 active nodes, can't simulate
        if (activeNodes.length < 2) {
          document.getElementById("packetStatus").innerHTML = 
            '<span class="inactive-connection">Need at least 2 active nodes for auto simulation</span>';
          addLogEntry("Auto simulation: Need at least 2 active nodes", "error");
          return;
        }
        
        // Randomly choose between unicast and broadcast (30% chance of broadcast)
        const shouldBroadcast = Math.random() < 0.3;
        
        if (shouldBroadcast) {
          // For broadcast, just pick a random source
          const source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
          broadcastPacket(source);
        } else {
          // For unicast, pick random source and target
          let source, target;
          do {
            source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
            target = activeNodes[Math.floor(Math.random() * activeNodes.length)];
          } while (source === target);
          
          // Send packet between these random nodes
          sendPacket(source, target);
        }
      }

      // Attach events
      document.getElementById("toggleHub").addEventListener("click", () => {
        toggleHub();
        blinkInactiveEdges();
      });

      document.getElementById("resetAll").addEventListener("click", () => {
        resetAll();
        blinkInactiveEdges();
      });

      document
        .getElementById("sendPacket")
        .addEventListener("click", () => sendPacket());
        
      document
        .getElementById("autoSimulate")
        .addEventListener("click", autoSimulate);
        
      document
        .getElementById("addNode")
        .addEventListener("click", addNode);
        
      document
        .getElementById("removeNode")
        .addEventListener("click", removeNode);

      // Initialize
      createNetwork();
      updateVisuals();
      blinkInactiveEdges();
      addLogEntry("Star Topology Simulator initialized", "info");

      /**
       * Demo sequence to showcase main features of the star topology simulator
       * Demonstrates node communication, failure handling, and broadcast capabilities
       */
      function runDemoSequence() {
        addLogEntry("Starting demonstration sequence...", "info");
        
        // Step 1: Basic packet transmission
        setTimeout(() => {
          document.getElementById("sourceNode").value = "node1";
          document.getElementById("targetNode").value = "node3";
          addLogEntry("Demo: Sending a packet from PC 1 to PC 3", "info");
          sendPacket();
        }, 1000);
        
        // Step 2: Show node failure scenario
        setTimeout(() => {
          addLogEntry("Demo: Simulating a node failure (PC 4)", "info");
          toggleNode("node4");
        }, 4000);
        
        // Step 3: Attempt transmission to failed node
        setTimeout(() => {
          document.getElementById("sourceNode").value = "node2";
          document.getElementById("targetNode").value = "node4";
          addLogEntry("Demo: Attempting to send to an inactive node", "info");
          sendPacket();
        }, 6000);
        
        // Step 4: Broadcast transmission
        setTimeout(() => {
          document.getElementById("sourceNode").value = "node5";
          document.querySelector('input[name="packetMode"][value="broadcast"]').checked = true;
          addLogEntry("Demo: Demonstrating broadcast capability from PC 5", "info");
          sendPacket();
        }, 9000);
        
        // Step 5: Hub failure scenario
        setTimeout(() => {
          addLogEntry("Demo: Simulating hub failure (central point of failure in star topology)", "info");
          toggleHub();
        }, 14000);
        
        // Step 6: Attempt transmission with failed hub
        setTimeout(() => {
          document.getElementById("sourceNode").value = "node1";
          document.getElementById("targetNode").value = "node2";
          document.querySelector('input[name="packetMode"][value="unicast"]').checked = true;
          addLogEntry("Demo: Attempting transmission with inactive hub", "info");
          sendPacket();
        }, 16000);
        
        // Step 7: Restore network
        setTimeout(() => {
          addLogEntry("Demo: Restoring network to normal operation", "info");
          resetAll();
        }, 19000);
        
        // Step 8: Run a quick load test
        setTimeout(() => {
          addLogEntry("Demo: Running network load test", "info");
          document.getElementById('loadTestPackets').value = 10;
          document.getElementById('loadTestPacketsValue').textContent = 10;
          runLoadTest();
        }, 21000);
        
        // Finish demo
        setTimeout(() => {
          addLogEntry("Demo sequence completed. Explore the simulator on your own!", "info");
        }, 25000);
      }
    </script>
  </body>
</html>