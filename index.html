<!DOCTYPE html>
<html>
  <head>
    <title>Star Topology Simulator</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
      /* Packet animation styles */
      .packet {
        position: absolute;
        width: 16px;
        height: 16px;
        background-color: #FFEB3B;
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(255, 235, 59, 0.8);
        z-index: 1000;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .packet-trail {
        position: absolute;
        width: 8px;
        height: 8px;
        background-color: rgba(255, 235, 59, 0.5);
        border-radius: 50%;
        z-index: 999;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .pulse-effect {
        animation: pulse 0.5s ease-out;
      }
      @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        100% { transform: scale(2); opacity: 0; }
      }

      /* Dracula Theme Variables */
      :root {
        --bg-light: #f7f9fc;
        --text-light: #2c3e50;
        --primary-light: #3498db;
        --secondary-light: #2980b9;
        --danger-light: #e74c3c;
        --success-light: #27ae60;
        --card-light: #ffffff;
        --border-light: #e0e6ed;

        --bg-dark: #282a36;
        --text-dark: #f8f8f2;
        --primary-dark: #bd93f9;
        --secondary-dark: #6272a4;
        --danger-dark: #ff5555;
        --success-dark: #50fa7b;
        --card-dark: #44475a;
        --border-dark: #6272a4;
      }

      body.light-theme {
        --bg: var(--bg-light);
        --text: var(--text-light);
        --primary: var(--primary-light);
        --secondary: var(--secondary-light);
        --danger: var(--danger-light);
        --success: var(--success-light);
        --card: var(--card-light);
        --border: var(--border-light);
      }

      body.dark-theme {
        --bg: var(--bg-dark);
        --text: var(--text-dark);
        --primary: var(--primary-dark);
        --secondary: var(--secondary-dark);
        --danger: var(--danger-dark);
        --success: var(--success-dark);
        --card: var(--card-dark);
        --border: var(--border-dark);
      }

      /* Theme Toggle Button */
      #themeToggle {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 8px 14px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 2px solid var(--border);
        font-size: 15px;
        font-weight: 500;
      }

      body.light-theme #themeToggle {
        background: #282a36;
        color: #f8f8f2;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      }

      body.dark-theme #themeToggle {
        background: #f8f8f2;
        color: #282a36;
        box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      }

      /* Layout styles */
      .main-layout {
        display: flex;
        min-height: 100vh;
      }

      .sidebar {
        width: 300px;
        flex-shrink: 0;
        padding: 20px;
        overflow-y: auto;
        height: 100vh;
        position: fixed;
        right: 0;
        top: 0;
        z-index: 10;
      }

      .main-content {
        flex-grow: 1;
        margin-right: 300px;
      }

      /* Packet Log */
      .packet-log {
        margin-top: 30px;
      }

      .packet-log h2 {
        font-size: 18px;
        margin-bottom: 15px;
        color: var(--primary);
      }

      .log-entry {
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        font-size: 14px;
        background: rgba(255,255,255,0.1);
      }

      .log-entry.source {
        border-left: 3px solid var(--primary);
      }

      .log-entry.target {
        border-left: 3px solid var(--success);
      }

      .log-entry.error {
        border-left: 3px solid var(--danger);
      }

      .log-container {
        max-height: 300px;
        overflow-y: auto;
        border-radius: 4px;
      }

      .log-time {
        color: var(--secondary);
        font-size: 12px;
        margin-bottom: 5px;
      }

      /* New UI element styles */
      .packet-mode {
        display: flex;
        gap: 20px;
        margin: 10px 0;
      }

      .packet-mode label {
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
      }

      .network-controls {
        display: flex;
        gap: 10px;
        margin: 15px 0;
      }

      /* Traffic visualization */
      .traffic-low {
        color: var(--success);
      }
      
      .traffic-medium {
        color: #FFA500; /* Orange */
      }
      
      .traffic-high {
        color: var(--danger);
      }
    </style>
  </head>
  <body class="light-theme">
    <button id="themeToggle">üåô Dracula Theme</button>
    
    <div class="main-layout">
      <div class="main-content">
        <h1>Star Topology Simulator</h1>
        
        <div class="legend">
          <div class="legend-item">
            <span class="legend-color" style="background: #1565c0"></span>Hub
          </div>
          <div class="legend-item">
            <span class="legend-color" style="background: #4caf50"></span>Active Node
          </div>
          <div class="legend-item">
            <span class="legend-color" style="background: #e53935"></span>Inactive Node
          </div>
          <div class="legend-item">
            <span class="legend-color" style="background: #ffeb3b"></span>Data Packet
          </div>
        </div>
        
        <div id="network"></div>
      </div>
      
      <div class="sidebar">
        <h2>Controls</h2>
        
        <div class="controls">
          <button id="toggleHub">Toggle Hub (ON)</button>
          <button id="resetAll">Reset All</button>
        </div>
        
        <div class="packet-controls">
          <select id="sourceNode">
            <option value="">Select Source Node</option>
            <option value="node1">PC 1</option>
            <option value="node2">PC 2</option>
            <option value="node3">PC 3</option>
            <option value="node4">PC 4</option>
            <option value="node5">PC 5</option>
            <option value="node6">PC 6</option>
          </select>
          <select id="targetNode">
            <option value="">Select Target Node</option>
            <option value="node1">PC 1</option>
            <option value="node2">PC 2</option>
            <option value="node3">PC 3</option>
            <option value="node4">PC 4</option>
            <option value="node5">PC 5</option>
            <option value="node6">PC 6</option>
          </select>
          <div class="packet-mode">
            <label><input type="radio" name="packetMode" value="unicast" checked> Unicast</label>
            <label><input type="radio" name="packetMode" value="broadcast"> Broadcast</label>
          </div>
          <button id="sendPacket">Send Packet</button>
          <button id="autoSimulate">Auto Simulate</button>
        </div>
        
        <div class="network-controls">
          <button id="addNode">Add Node</button>
          <button id="removeNode">Remove Node</button>
        </div>
        
        <div class="status" id="status">
          All connections <span class="active-connection">ACTIVE</span>
        </div>
        
        <div class="status" id="packetStatus"></div>
        
        <div class="packet-log">
          <h2>Packet Log</h2>
          <div class="log-container" id="packetLog"></div>
        </div>
      </div>
    </div>

    <script>
      const ipConfigurations = {
        hub: "192.168.1.1",
        node1: "192.168.1.2",
        node2: "192.168.1.3",
        node3: "192.168.1.4",
        node4: "192.168.1.5",
        node5: "192.168.1.6",
        node6: "192.168.1.7",
      };

      const HUB_ACTIVE = "#1565C0";
      const HUB_INACTIVE = "#E53935";
      const NODE_ACTIVE = "#4CAF50";
      const NODE_INACTIVE = "#E53935";
      const PACKET_COLOR = "#FFEB3B";
      const PACKET_SPEED = 750;

      let data, network;
      let hubActive = true;
      let nodeStatus = {};
      let blinkInterval;
      let isAnimatingPacket = false;
      let autoSimulateInterval = null;
      let packetElements = [];
      let packetLogEntries = [];
      let nodeCount = 6; // Track the current number of nodes
      let trafficData = {}; // Track traffic on each connection
      let lastBroadcastTime = 0; // Prevent broadcast spam

      // Initialize theme based on user preference
      document.addEventListener('DOMContentLoaded', function() {
        // Check for saved theme preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
          document.body.className = savedTheme;
          updateThemeToggleText();
        }
      });
      
      // Theme toggle
      document.getElementById("themeToggle").addEventListener("click", function() {
        const body = document.body;
        if (body.classList.contains("light-theme")) {
          body.classList.remove("light-theme");
          body.classList.add("dark-theme");
          localStorage.setItem('theme', 'dark-theme');
        } else {
          body.classList.remove("dark-theme");
          body.classList.add("light-theme");
          localStorage.setItem('theme', 'light-theme');
        }
        updateThemeToggleText();
      });
      
      // Update theme toggle button text
      function updateThemeToggleText() {
        const button = document.getElementById("themeToggle");
        if (document.body.classList.contains("dark-theme")) {
          button.textContent = "‚òÄÔ∏è Light Theme";
        } else {
          button.textContent = "üåô Dracula Theme";
        }
      }

      function createNetwork() {
        const nodes = [
          {
            id: "hub",
            label: "Hub",
            shape: "image",
            image: "switch-hub.png",
            size: 50,
            font: { size: 16 },
            fixed: true,
            x: 0,
            y: 0,
            borderWidth: 6,
            borderWidthSelected: 6,
            color: { border: HUB_ACTIVE, background: "rgba(255,255,255,0.9)" },
            shadow: true,
            shadowColor: "#1565C0", // blue for hub
            shadowSize: 28,
            shadowX: 0,
            shadowY: 0,
          },
        ];

        const edges = [];
        const radius = 300;

        for (let i = 1; i <= nodeCount; i++) {
          const angle = (i - 1) * ((2 * Math.PI) / nodeCount);
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          const nodeId = `node${i}`;
          
          // Initialize traffic data for this connection if it doesn't exist
          if (!trafficData[nodeId]) {
            trafficData[nodeId] = {
              packetsSent: 0,
              packetsReceived: 0,
              lastUpdate: Date.now()
            };
          }
          
          // Initialize node status if it doesn't exist
          if (nodeStatus[nodeId] === undefined) {
            nodeStatus[nodeId] = true;
          }
          
          // Get the IP (use existing or generate new)
          const nodeIP = ipConfigurations[nodeId] || generateIP(i);
          
          // Make sure IP is in configurations
          if (!ipConfigurations[nodeId]) {
            ipConfigurations[nodeId] = nodeIP;
          }
          
          nodes.push({
            id: nodeId,
            label: `PC ${i}`,
            title: `IP: ${nodeIP}`,
            shape: "image",
            image: "desktop.png",
            size: 40,
            font: { size: 14 },
            fixed: true,
            x,
            y,
            borderWidth: 4,
            borderWidthSelected: 4,
            color: { 
              border: nodeStatus[nodeId] ? NODE_ACTIVE : NODE_INACTIVE, 
              background: "rgba(255,255,255,0.7)" 
            },
            shadow: true,
            shadowColor: nodeStatus[nodeId] ? "#4CAF50" : "#E53935", // green if active, red if inactive
            shadowSize: 20,
            shadowX: 0,
            shadowY: 0,
          });
          edges.push({
            id: `edge${i}`,
            from: "hub",
            to: nodeId,
            color: { color: "#000000" },
            width: 2,
          });
        }

        // If network already exists, destroy it first
        if (network) {
          network.destroy();
          // Clean up any packet elements
          cleanupPacketElements();
        }

        data = {
          nodes: new vis.DataSet(nodes),
          edges: new vis.DataSet(edges),
        };

        network = new vis.Network(document.getElementById("network"), data, {
          physics: false,
          interaction: {
            dragNodes: false,
            dragView: false,
            zoomView: false,
          },
          autoResize: false, // Prevent auto-resizing
          height: "800px",
          width: "800px",
        });

        network.on("click", (params) => {
          if (params.nodes.length && params.nodes[0] !== "hub") {
            toggleNode(params.nodes[0]);
          }
        });
        
        // Update node selectors in UI
        updateNodeSelectors();
      }

      // Generate IP for newly added nodes
      function generateIP(nodeIndex) {
        return `192.168.1.${nodeIndex + 1}`;
      }
      
      // Update node selectors in UI
      function updateNodeSelectors() {
        const sourceSelect = document.getElementById("sourceNode");
        const targetSelect = document.getElementById("targetNode");
        
        // Save current selections
        const sourceVal = sourceSelect.value;
        const targetVal = targetSelect.value;
        
        // Clear options
        sourceSelect.innerHTML = '<option value="">Select Source Node</option>';
        targetSelect.innerHTML = '<option value="">Select Target Node</option>';
        
        // Add options for all current nodes
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          
          // Add to source selector
          const sourceOpt = document.createElement('option');
          sourceOpt.value = nodeId;
          sourceOpt.textContent = `PC ${i}`;
          sourceSelect.appendChild(sourceOpt);
          
          // Add to target selector
          const targetOpt = document.createElement('option');
          targetOpt.value = nodeId;
          targetOpt.textContent = `PC ${i}`;
          targetSelect.appendChild(targetOpt);
        }
        
        // Restore previous selections if they still exist
        if (sourceVal && parseInt(sourceVal.replace('node', '')) <= nodeCount) {
          sourceSelect.value = sourceVal;
        }
        if (targetVal && parseInt(targetVal.replace('node', '')) <= nodeCount) {
          targetSelect.value = targetVal;
        }
      }

      // Log packet activity
      function addLogEntry(message, type = "info") {
        const logContainer = document.getElementById("packetLog");
        const time = new Date().toLocaleTimeString();
        
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        
        const timeSpan = document.createElement("div");
        timeSpan.className = "log-time";
        timeSpan.textContent = time;
        
        const messageDiv = document.createElement("div");
        messageDiv.innerHTML = message;
        
        entry.appendChild(timeSpan);
        entry.appendChild(messageDiv);
        
        // Keep only the latest 50 entries
        packetLogEntries.push(entry);
        if (packetLogEntries.length > 50) {
          packetLogEntries.shift();
        }
        
        // Clear and repopulate the log
        logContainer.innerHTML = "";
        packetLogEntries.forEach(item => {
          logContainer.appendChild(item);
        });
        
        // Scroll to bottom
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      function toggleNode(nodeId) {
        nodeStatus[nodeId] = !nodeStatus[nodeId];
        const status = nodeStatus[nodeId] ? "active" : "inactive";
        addLogEntry(`Node ${nodeId.replace("node", "PC ")} is now <span class="${status}-connection">${status.toUpperCase()}</span>`, "info");
        updateVisuals();
      }

      function toggleHub() {
        hubActive = !hubActive;
        document.getElementById("toggleHub").textContent = `Toggle Hub (${
          hubActive ? "ON" : "OFF"
        })`;
        const status = hubActive ? "active" : "inactive";
        addLogEntry(`Hub is now <span class="${status}-connection">${status.toUpperCase()}</span>`, hubActive ? "info" : "error");
        updateVisuals();
      }

      function resetAll() {
        hubActive = true;
        for (let id in nodeStatus) nodeStatus[id] = true;
        document.getElementById("toggleHub").textContent = `Toggle Hub (ON)`;
        addLogEntry("All nodes and hub have been reset to <span class=\"active-connection\">ACTIVE</span>", "info");
        updateVisuals();
      }

      function updateVisuals() {
        // Update hub visual state
        const hubNode = data.nodes.get("hub");
        if (hubActive) {
          hubNode.borderWidth = 4;
          hubNode.borderWidthSelected = 4;
          hubNode.color = { border: HUB_ACTIVE };
          hubNode.shadowColor = HUB_ACTIVE;
        } else {
          hubNode.borderWidth = 4;
          hubNode.borderWidthSelected = 4;
          hubNode.color = { border: HUB_INACTIVE };
          hubNode.shadowColor = HUB_INACTIVE;
        }
        data.nodes.update(hubNode);

        // Update each node's visual state
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          if (!data.nodes.get(nodeId)) continue; // Skip if node doesn't exist
          
          const edgeId = `edge${i}`;
          const active = nodeStatus[nodeId] && hubActive;

          // Update node appearance
          const node = data.nodes.get(nodeId);
          node.borderWidth = 4;
          node.borderWidthSelected = 4;
          node.color = {
            border: nodeStatus[nodeId] ? NODE_ACTIVE : NODE_INACTIVE,
          };
          node.shadowColor = nodeStatus[nodeId] ? NODE_ACTIVE : NODE_INACTIVE;
          data.nodes.update(node);

          // Update edge appearance and incorporate traffic data
          const trafficLevel = getTrafficLevel(nodeId);
          let edgeWidth = 2;
          
          // Adjust edge width based on traffic
          if (trafficLevel === 'medium') edgeWidth = 3;
          if (trafficLevel === 'high') edgeWidth = 4;
          
          data.edges.update({
            id: edgeId,
            color: {
              color: active ? "#000000" : "#E53935",
              opacity: 1,
            },
            width: edgeWidth,
            dashes: !active, // dashes for inactive connections
            title: `Traffic: ${trafficData[nodeId].packetsSent + trafficData[nodeId].packetsReceived} packets`
          });
        }

        updateStatusText();

        // Force blinking to restart after updating visuals
        if (blinkInterval) {
          clearInterval(blinkInterval);
          blinkInactiveEdges();
        }
      }

      // Get traffic level for a node connection
      function getTrafficLevel(nodeId) {
        if (!trafficData[nodeId]) return 'low';
        
        const totalPackets = trafficData[nodeId].packetsSent + trafficData[nodeId].packetsReceived;
        const timeSinceStart = (Date.now() - trafficData[nodeId].lastUpdate) / 1000;
        
        // Reset traffic if it's been a while
        if (timeSinceStart > 60) {
          trafficData[nodeId].packetsSent = 0;
          trafficData[nodeId].packetsReceived = 0;
          trafficData[nodeId].lastUpdate = Date.now();
          return 'low';
        }
        
        // Calculate packets per second
        const packetsPerSecond = totalPackets / Math.max(timeSinceStart, 1);
        
        if (packetsPerSecond > 0.5) return 'high';
        if (packetsPerSecond > 0.2) return 'medium';
        return 'low';
      }

      function updateStatusText() {
        const statusEl = document.getElementById("status");
        if (!hubActive) {
          statusEl.innerHTML =
            'Hub is <span class="inactive-connection">OFF</span> - All connections inactive';
          return;
        }

        const activeCount = Object.keys(nodeStatus)
          .filter(id => parseInt(id.replace('node', '')) <= nodeCount) // Only consider existing nodes
          .filter(id => nodeStatus[id]).length;
        
        if (activeCount === nodeCount) {
          statusEl.innerHTML =
            'All connections <span class="active-connection">ACTIVE</span>';
        } else if (activeCount === 0) {
          statusEl.innerHTML =
            'All nodes <span class="inactive-connection">INACTIVE</span>';
        } else {
          statusEl.innerHTML = `<span class="active-connection">${activeCount}</span> active, <span class="inactive-connection">${
            nodeCount - activeCount
          }</span> inactive`;
        }
      }

      function blinkInactiveEdges() {
        let toggle = false;
        clearInterval(blinkInterval);
        blinkInterval = setInterval(() => {
          for (let i = 1; i <= nodeCount; i++) {
            const nodeId = `node${i}`;
            const edgeId = `edge${i}`;
            
            // Skip if node or edge doesn't exist
            if (!data.nodes.get(nodeId) || !data.edges.get(edgeId)) continue;
            
            const active = nodeStatus[nodeId] && hubActive;

            if (!active) {
              // For inactive connections, blink the edges
              data.edges.update({
                id: edgeId,
                color: { color: toggle ? "#E53935" : "#FF0000" }, // Dark red to bright red blink
                dashes: true,
                width: toggle ? 2 : 3, // Slightly change width for more visible blinking
              });
            }
          }
          toggle = !toggle;
        }, 500);
      }

      // Animate packet along a path with requestAnimationFrame for smooth motion
      function animatePacketAlongPath(x1, y1, x2, y2, centerX, centerY, onComplete) {
        const networkDiv = document.getElementById('network');
        if (!networkDiv) {
          console.error("Network div not found");
          if (onComplete) onComplete();
          return;
        }
        
        const packet = createPacketElement();
        packetElements.push(packet);

        // Use #network's center for calculations
        const startX = (networkDiv.clientWidth / 2) + x1;
        const startY = (networkDiv.clientHeight / 2) + y1;
        const endX = (networkDiv.clientWidth / 2) + x2;
        const endY = (networkDiv.clientHeight / 2) + y2;

        // Duration in milliseconds
        const duration = PACKET_SPEED;
        const startTime = performance.now();
        
        // Setup for trailing effect
        const trailInterval = 100; // ms between trail elements
        let lastTrailTime = 0;
        
        // Animation function
        function animate(currentTime) {
          // Safety check if we exited the animation early
          if (!packet.parentNode) {
            if (onComplete) onComplete();
            return;
          }
          
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // Ease in-out function for smoother movement
          const easedProgress = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          // Calculate current position
          const currentX = startX + (endX - startX) * easedProgress;
          const currentY = startY + (endY - startY) * easedProgress;
          
          // Set packet position
          packet.style.left = `${currentX}px`;
          packet.style.top = `${currentY}px`;
          
          // Create trail effect
          if (currentTime - lastTrailTime > trailInterval && progress > 0.1 && progress < 0.9) {
            lastTrailTime = currentTime;
            const trail = createTrailElement();
            trail.style.left = `${currentX}px`;
            trail.style.top = `${currentY}px`;
            packetElements.push(trail);
            
            // Fade out and remove trail element
            setTimeout(() => {
              if (trail && trail.parentNode) {
                trail.style.opacity = '0';
                setTimeout(() => {
                  if (trail && trail.parentNode) trail.parentNode.removeChild(trail);
                  const index = packetElements.indexOf(trail);
                  if (index !== -1) packetElements.splice(index, 1);
                }, 300);
              }
            }, 200);
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Animation complete
            setTimeout(() => {
              if (packet && packet.parentNode) packet.parentNode.removeChild(packet);
              const index = packetElements.indexOf(packet);
              if (index !== -1) packetElements.splice(index, 1);
              
              if (onComplete) onComplete();
            }, 100);
          }
        }
        
        // Start animation
        requestAnimationFrame(animate);
      }
      
      // Create visual packet
      function createPacketElement() {
        const packet = document.createElement('div');
        packet.className = 'packet';
        const networkDiv = document.querySelector('#network');
        if (networkDiv) {
          networkDiv.appendChild(packet);
        }
        return packet;
      }
      
      // Create packet trail
      function createTrailElement() {
        const trail = document.createElement('div');
        trail.className = 'packet-trail';
        const networkDiv = document.querySelector('#network');
        if (networkDiv) {
          networkDiv.appendChild(trail);
        }
        return trail;
      }
      
      // Clean up visual elements
      function cleanupPacketElements() {
        packetElements.forEach(element => {
          if (element && element.parentNode) {
            element.parentNode.removeChild(element);
          }
        });
        packetElements = [];
      }
      
      // Add pulse effect to a node
      function pulseEffect(nodeId) {
        const positions = network.getPositions([nodeId]);
        if (!positions || !positions[nodeId]) {
          console.error("Node position not found:", nodeId);
          return;
        }
        
        const nodePosition = positions[nodeId];
        const networkDiv = document.getElementById('network');
        if (!networkDiv) return;
        
        const rect = networkDiv.getBoundingClientRect();

        // Calculate position relative to #network
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const x = centerX + nodePosition.x;
        const y = centerY + nodePosition.y;

        // Create pulse element
        const pulse = document.createElement('div');
        pulse.className = 'packet pulse-effect';
        pulse.style.left = `${x}px`;
        pulse.style.top = `${y}px`;
        networkDiv.appendChild(pulse);
        packetElements.push(pulse);

        // Remove after animation completes
        setTimeout(() => {
          if (pulse && pulse.parentNode) pulse.parentNode.removeChild(pulse);
          const index = packetElements.indexOf(pulse);
          if (index !== -1) packetElements.splice(index, 1);
        }, 500);
      }

      function sendPacket(source = null, target = null) {
        // Check if in broadcast mode - only applies when user clicks the Send Packet button
        // If sources and targets are provided directly, use unicast
        const isBroadcast = document.querySelector('input[name="packetMode"]:checked')?.value === 'broadcast' && !target;
        
        // If in broadcast mode with no target specified, use broadcast function
        if (isBroadcast) {
          broadcastPacket(source);
          return;
        }
        
        // Prevent multiple animations running at once
        if (isAnimatingPacket) {
          return;
        }

        // If source and target aren't provided, get them from the selects
        if (!source || !target) {
          const sourceSelect = document.getElementById("sourceNode");
          const targetSelect = document.getElementById("targetNode");
          source = sourceSelect.value;
          target = targetSelect.value;
        }
        
        const packetStatusEl = document.getElementById("packetStatus");

        if (!source || !target) {
          packetStatusEl.innerHTML =
            '<span class="inactive-connection">Please select both source and target nodes</span>';
          addLogEntry("Packet transmission failed: Source or target not selected", "error");
          return;
        }

        if (source === target) {
          packetStatusEl.innerHTML =
            '<span class="inactive-connection">Source and target cannot be the same</span>';
          addLogEntry("Packet transmission failed: Source and target are the same", "error");
          return;
        }

        if (!hubActive) {
          packetStatusEl.innerHTML =
            '<span class="inactive-connection">Cannot send packet: Hub is OFF</span>';
          addLogEntry("Packet transmission failed: Hub is OFF", "error");
          return;
        }

        if (!nodeStatus[source]) {
          packetStatusEl.innerHTML = `<span class="inactive-connection">Cannot send packet: Source ${source.replace(
            "node",
            "PC "
          )} is inactive</span>`;
          addLogEntry(`Packet transmission failed: Source ${source.replace("node", "PC ")} is inactive`, "error");
          return;
        }

        if (!nodeStatus[target]) {
          packetStatusEl.innerHTML = `<span class="inactive-connection">Cannot send packet: Target ${target.replace(
            "node",
            "PC "
          )} is inactive</span>`;
          addLogEntry(`Packet transmission failed: Target ${target.replace("node", "PC ")} is inactive`, "error");
          return;
        }

        // Successfully sending packet
        packetStatusEl.innerHTML = `<span class="active-connection">Sending packet from ${source.replace(
          "node",
          "PC "
        )} to ${target.replace("node", "PC ")}</span>`;
        
        addLogEntry(`Sending packet from ${source.replace("node", "PC ")} (${ipConfigurations[source] || generateIP(parseInt(source.replace("node", "")))}) to ${target.replace("node", "PC ")} (${ipConfigurations[target] || generateIP(parseInt(target.replace("node", "")))})`, "source");

        // Track traffic
        trafficData[source].packetsSent++;
        trafficData[target].packetsReceived++;

        isAnimatingPacket = true;

        // Temporarily pause blinking during animation
        clearInterval(blinkInterval);
        
        // Clean up any existing packet elements
        cleanupPacketElements();

        // Add pulse effect to source node
        pulseEffect(source);

        // Animate the packet using the edges
        setTimeout(() => {
          animatePacket(source, target);
        }, 300);
      }

      // New function to handle broadcast packet sending
      function broadcastPacket(source = null) {
        // Prevent spam
        const now = Date.now();
        if (now - lastBroadcastTime < 1000) {
          return;
        }
        lastBroadcastTime = now;
        
        // Prevent multiple animations running at once
        if (isAnimatingPacket) {
          return;
        }
        
        // If source isn't provided, get it from the select
        if (!source) {
          const sourceSelect = document.getElementById("sourceNode");
          source = sourceSelect.value;
        }
        
        const packetStatusEl = document.getElementById("packetStatus");
        
        if (!source) {
          packetStatusEl.innerHTML = 
            '<span class="inactive-connection">Please select a source node</span>';
          addLogEntry("Broadcast failed: Source not selected", "error");
          return;
        }
        
        if (!hubActive) {
          packetStatusEl.innerHTML =
            '<span class="inactive-connection">Cannot broadcast: Hub is OFF</span>';
          addLogEntry("Broadcast failed: Hub is OFF", "error");
          return;
        }
        
        if (!nodeStatus[source]) {
          packetStatusEl.innerHTML = `<span class="inactive-connection">Cannot broadcast: Source ${source.replace(
            "node", "PC "
          )} is inactive</span>`;
          addLogEntry(`Broadcast failed: Source ${source.replace("node", "PC ")} is inactive`, "error");
          return;
        }
        
        // Find all active targets (except source)
        const targets = [];
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          if (nodeId !== source && nodeStatus[nodeId]) {
            targets.push(nodeId);
          }
        }
        
        if (targets.length === 0) {
          packetStatusEl.innerHTML = 
            '<span class="inactive-connection">Cannot broadcast: No active target nodes</span>';
          addLogEntry("Broadcast failed: No active target nodes", "error");
          return;
        }
        
        // Successfully broadcasting
        packetStatusEl.innerHTML = `<span class="active-connection">Broadcasting packet from ${source.replace(
          "node", "PC "
        )} to ${targets.length} nodes</span>`;
        
        addLogEntry(`Broadcasting packet from ${source.replace("node", "PC ")} (${ipConfigurations[source] || generateIP(parseInt(source.replace("node", "")))}) to all active nodes`, "source");
        
        isAnimatingPacket = true;
        
        // Temporarily pause blinking during animation
        clearInterval(blinkInterval);
        
        // Clean up any existing packet elements
        cleanupPacketElements();
        
        // Add pulse effect to source node
        pulseEffect(source);
        
        // Animate broadcast packets (source to hub first)
        setTimeout(() => {
          animateBroadcast(source, targets);
        }, 300);
      }
      
      function animateBroadcast(source, targets) {
        // Get positions for source, hub, and all targets
        const nodeIds = [source, "hub", ...targets];
        const positions = network.getPositions(nodeIds);
        
        // Track traffic for broadcast
        trafficData[source].packetsSent += targets.length;
        targets.forEach(target => {
          if (trafficData[target]) {
            trafficData[target].packetsReceived++;
          }
        });
        
        // Canvas coordinates for center reference
        const canvas = document.querySelector('#network canvas');
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + (rect.width / 2);
        const centerY = rect.top + (rect.height / 2);
        
        // First animate from source to hub
        animatePacketAlongPath(
          positions[source].x, positions[source].y,
          positions["hub"].x, positions["hub"].y,
          centerX, centerY,
          () => {
            // Add pulse effect to hub
            pulseEffect("hub");
            addLogEntry(`Packet arrived at hub, processing broadcast routing`, "info");
            
            // Create a sequence of animations (hub to each target)
            let animationSequence = Promise.resolve();
            
            // Use a delay multiple
            const delayMultiple = 200;
            
            // Then animate from hub to each target with staggered timing
            targets.forEach((target, index) => {
              // Check if target still exists
              if (!positions[target]) return;
              
              animationSequence = animationSequence.then(() => {
                return new Promise(resolve => {
                  setTimeout(() => {
                    addLogEntry(`Broadcasting to ${target.replace("node", "PC ")}`, "info");
                    animatePacketAlongPath(
                      positions["hub"].x, positions["hub"].y,
                      positions[target].x, positions[target].y,
                      centerX, centerY,
                      () => {
                        // Add pulse effect to target node
                        pulseEffect(target);
                        addLogEntry(`Packet delivered to ${target.replace("node", "PC ")} (${ipConfigurations[target] || generateIP(parseInt(target.replace("node", "")))})`, "target");
                        resolve();
                      }
                    );
                  }, index * delayMultiple);
                });
              });
            });
            
            // When all animations complete
            animationSequence.then(() => {
              document.getElementById("packetStatus").innerHTML = 
                `<span class="active-connection">Broadcast successfully delivered from ${source.replace(
                  "node", "PC "
                )} to ${targets.length} nodes</span>`;
                
              // Animation complete
              isAnimatingPacket = false;
              
              // Restart blinking for inactive edges
              blinkInactiveEdges();
              
              // Update visuals to reflect traffic changes
              updateVisuals();
            });
          }
        );
      }

      function animatePacket(source, target) {
        // Get source, hub, and target positions
        const positions = network.getPositions([source, "hub", target]);
        const sourcePos = positions[source];
        const hubPos = positions["hub"];
        const targetPos = positions[target];
        
        // Get DOM positions from network positions
        const canvas = document.querySelector('#network canvas');
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + (rect.width / 2);
        const centerY = rect.top + (rect.height / 2);
        
        // Step 1: Animate from source to hub
        addLogEntry(`Packet traveling from ${source.replace("node", "PC ")} to hub`, "info");
        animatePacketAlongPath(
          sourcePos.x, sourcePos.y,
          hubPos.x, hubPos.y,
          centerX, centerY,
          () => {
            // Add pulse effect to hub
            pulseEffect("hub");
            addLogEntry(`Packet arrived at hub, processing routing`, "info");
            
            // Step 2: After reaching hub, animate to target
            setTimeout(() => {
              addLogEntry(`Packet traveling from hub to ${target.replace("node", "PC ")}`, "info");
              animatePacketAlongPath(
                hubPos.x, hubPos.y,
                targetPos.x, targetPos.y,
                centerX, centerY,
                () => {
                  // Add pulse effect to target node
                  pulseEffect(target);
                  
                  // Update status
                  document.getElementById("packetStatus").innerHTML = 
                    `<span class="active-connection">Packet successfully delivered from ${source.replace(
                      "node", "PC "
                    )} to ${target.replace("node", "PC ")}</span>`;
                  
                  addLogEntry(`Packet successfully delivered to ${target.replace("node", "PC ")} (${ipConfigurations[target] || generateIP(parseInt(target.replace("node", "")))})`, "target");
                  
                  // Animation complete
                  isAnimatingPacket = false;
                  
                  // Restart blinking for inactive edges
                  blinkInactiveEdges();
                  
                  // Update visuals to reflect traffic changes
                  updateVisuals();
                }
              );
            }, 300); // Wait a bit at the hub
          }
        );
      }

      // Add a new node to the network
      function addNode() {
        // Stop any ongoing animations
        if (isAnimatingPacket) {
          cleanupPacketElements();
          isAnimatingPacket = false;
        }
        
        nodeCount++;
        const newNodeId = `node${nodeCount}`;
        
        // Initialize node status and traffic data
        nodeStatus[newNodeId] = true;
        trafficData[newNodeId] = {
          packetsSent: 0,
          packetsReceived: 0,
          lastUpdate: Date.now()
        };
        
        // Add new IP to configurations if needed
        if (!ipConfigurations[newNodeId]) {
          ipConfigurations[newNodeId] = generateIP(nodeCount);
        }
        
        // Rebuild the network with the new node count
        createNetwork();
        addLogEntry(`Added new node: PC ${nodeCount} (${ipConfigurations[newNodeId]})`, "info");
        
        // Update visuals
        updateVisuals();
      }
      
      // Remove the last node from the network
      function removeNode() {
        if (nodeCount <= 2) {
          addLogEntry("Cannot remove node: Minimum 2 nodes required", "error");
          return;
        }
        
        // Stop any ongoing animations
        if (isAnimatingPacket) {
          cleanupPacketElements();
          isAnimatingPacket = false;
        }
        
        const removedNodeId = `node${nodeCount}`;
        addLogEntry(`Removed node: PC ${nodeCount} (${ipConfigurations[removedNodeId] || generateIP(nodeCount)})`, "info");
        
        // Clean up node status and traffic data
        delete nodeStatus[removedNodeId];
        delete trafficData[removedNodeId];
        
        // Decrement node count and rebuild network
        nodeCount--;
        createNetwork();
        
        // Update visuals
        updateVisuals();
      }

      // New function for auto simulation
      function autoSimulate() {
        const button = document.getElementById("autoSimulate");
        
        if (autoSimulateInterval) {
          // Stop auto simulation
          clearInterval(autoSimulateInterval);
          autoSimulateInterval = null;
          button.textContent = "Auto Simulate";
          addLogEntry("Auto simulation stopped", "info");
          return;
        }
        
        // Start auto simulation
        button.textContent = "Stop Auto Simulate";
        addLogEntry("Auto simulation started", "info");
        
        // Run the first simulation immediately
        runOneSimulation();
        
        autoSimulateInterval = setInterval(runOneSimulation, PACKET_SPEED * 3);
      }
      
      // Helper function to run a single simulation step
      function runOneSimulation() {
        if (isAnimatingPacket) return; // Don't start new animation if one is in progress
        
        // Get all active nodes
        const activeNodes = [];
        for (let i = 1; i <= nodeCount; i++) {
          const nodeId = `node${i}`;
          if (nodeStatus[nodeId] && hubActive) {
            activeNodes.push(nodeId);
          }
        }
        
        // If less than 2 active nodes, can't simulate
        if (activeNodes.length < 2) {
          document.getElementById("packetStatus").innerHTML = 
            '<span class="inactive-connection">Need at least 2 active nodes for auto simulation</span>';
          addLogEntry("Auto simulation: Need at least 2 active nodes", "error");
          return;
        }
        
        // Randomly choose between unicast and broadcast (30% chance of broadcast)
        const shouldBroadcast = Math.random() < 0.3;
        
        if (shouldBroadcast) {
          // For broadcast, just pick a random source
          const source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
          broadcastPacket(source);
        } else {
          // For unicast, pick random source and target
          let source, target;
          do {
            source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
            target = activeNodes[Math.floor(Math.random() * activeNodes.length)];
          } while (source === target);
          
          // Send packet between these random nodes
          sendPacket(source, target);
        }
      }

      // Attach events
      document.getElementById("toggleHub").addEventListener("click", () => {
        toggleHub();
        blinkInactiveEdges();
      });

      document.getElementById("resetAll").addEventListener("click", () => {
        resetAll();
        blinkInactiveEdges();
      });

      document
        .getElementById("sendPacket")
        .addEventListener("click", () => sendPacket());
        
      document
        .getElementById("autoSimulate")
        .addEventListener("click", autoSimulate);
        
      document
        .getElementById("addNode")
        .addEventListener("click", addNode);
        
      document
        .getElementById("removeNode")
        .addEventListener("click", removeNode);

      // Initialize
      createNetwork();
      updateVisuals();
      blinkInactiveEdges();
      addLogEntry("Star Topology Simulator initialized", "info");
    </script>
  </body>
</html>